<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tr·∫°ng th√°i t·∫•t c·∫£ qu·∫ßy d·ªãch v·ª•</title>
  <style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }
  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
    height: 100vh;
    max-height: 100vh;
    overflow: hidden;
    padding: 0;
    margin: 0;
    color: #333;
    display: flex;
    flex-direction: column;
    position: relative;
  }
  
  body::before {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: 
      radial-gradient(circle at 20% 80%, rgba(255,255,255,0.1) 0%, transparent 50%),
      radial-gradient(circle at 80% 20%, rgba(255,255,255,0.08) 0%, transparent 50%);
    pointer-events: none;
    z-index: 0;
  }
  .container {
    width: 100vw;
    height: 100vh;
    display: flex;
    flex-direction: column;
    padding: 1vh;
    position: relative;
    z-index: 1;
  }
  .header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: rgba(255,255,255,0.12);
    backdrop-filter: blur(25px);
    border: 1px solid rgba(255,255,255,0.25);
    padding: 2vh 4vh;
    border-radius: 20px;
    box-shadow: 
      0 10px 40px rgba(0,0,0,0.15),
      inset 0 1px 0 rgba(255,255,255,0.25);
    flex-shrink: 0;
    position: relative;
    height: 14vh;
  }
  .logo-section {
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  .logo-section img {
    width: 60vh;
    height: 12vh;
    object-fit: contain;
    filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));
    border-radius: 12px;
  }
  .time {
    position: absolute;
    top: 50%;
    right: 0;
    transform: translateY(-50%);
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 0.5vh;
  }
  .time-hour {
    font-size: 3.2vh;
    font-weight: 700;
    color: #00ff88;
    text-shadow: 0 0 10px rgba(0, 255, 136, 0.5), 0 2px 4px rgba(0,0,0,0.5);
    letter-spacing: 1px;
  }
  .time-date {
    font-size: 1.6vh;
    font-weight: 500;
    color: rgba(255,255,255,0.9);
    text-shadow: 0 1px 3px rgba(0,0,0,0.4);
    white-space: nowrap;
  }
  .counters-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    grid-template-rows: 1fr;
    gap: 2vh;
    flex: 1;
    height: calc(100vh - 14vh);
    padding: 2vh 3vh;
    justify-content: center;
    align-content: center;
    max-width: 100%;
    margin: 0 auto;
    place-items: stretch;
  }
  .counter-card {
    background: linear-gradient(145deg, rgba(255,255,255,0.15), rgba(255,255,255,0.08));
    backdrop-filter: blur(30px);
    border: 2px solid rgba(255,255,255,0.2);
    padding: 1.8vh;
    border-radius: 20px;
    box-shadow: 
      0 12px 40px rgba(0,0,0,0.18),
      inset 0 2px 0 rgba(255,255,255,0.3);
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    border-left: 0.6vh solid rgba(255,255,255,0.5);
    display: flex;
    flex-direction: column;
    min-height: 0;
    overflow: hidden;
    position: relative;
    aspect-ratio: 3/4;
  }
  .counter-card::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.1) 0%, transparent 70%);
    pointer-events: none;
    z-index: 0;
  }
  .counter-card.active {
    border-left-color: #00ff88;
    background: linear-gradient(145deg, rgba(0, 255, 136, 0.2), rgba(0, 255, 136, 0.1));
    transform: translateY(-3px) scale(1.01);
    box-shadow: 
      0 20px 60px rgba(0, 255, 136, 0.3),
      inset 0 2px 0 rgba(255,255,255,0.4);
  }
  .counter-card:hover {
    transform: translateY(-2px) scale(1.005);
    box-shadow: 0 15px 50px rgba(0,0,0,0.22);
  }
  .counter-header {
    display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
    margin-bottom: 1.5vh;
    padding-bottom: 1vh;
    border-bottom: 2px solid rgba(255,255,255,0.3);
    flex-shrink: 0;
    position: relative;
    z-index: 1;
  }
  .counter-number {
    font-size: 3vh;
    font-weight: 900;
    background: linear-gradient(135deg, #667eea, #764ba2);
    color: white;
    padding: 0.8vh 1.8vh;
    border-radius: 15px;
    box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
    flex-shrink: 0;
    border: 2px solid rgba(255,255,255,0.3);
    text-shadow: 0 2px 4px rgba(0,0,0,0.3);
    letter-spacing: 0.5px;
  }
  .service-name {
    margin-top: 0.8vh;
    font-size: 2vh;
    font-weight: 700;
    color: rgba(255,255,255,0.95);
    text-align: center;
    text-shadow: 0 2px 4px rgba(0,0,0,0.4);
    line-height: 1.2;
    padding: 0 1vh;
    word-break: break-word;
  }
  .current-calling {
    background: linear-gradient(135deg, rgba(255, 255, 255, 0.18), rgba(255, 255, 255, 0.08));
    backdrop-filter: blur(15px);
    padding: 2vh 1.5vh;
    border-radius: 15px;
    margin-bottom: 1vh;
    border: 1.5px solid rgba(255, 255, 255, 0.3);
    flex: 1;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    overflow: hidden;
    box-shadow: 0 6px 20px rgba(0,0,0,0.12);
    position: relative;
    z-index: 1;
  }
  .calling-label {
    font-size: 1.4vh;
    color: rgba(255,255,255,0.9);
    margin-bottom: 0.8vh;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 1px;
    text-shadow: 0 2px 4px rgba(0,0,0,0.4);
  }
  .calling-number {
    font-size: 4.5vh;
    font-weight: 900;
    color: #00ff88;
    margin-bottom: 0.8vh;
    text-shadow: 
      0 0 15px rgba(0, 255, 136, 0.6),
      0 3px 6px rgba(0,0,0,0.5);
    text-align: center;
    letter-spacing: 1.5px;
  }
  .calling-time {
    font-size: 1.1vh;
    color: rgba(255,255,255,0.8);
    font-style: italic;
    text-align: center;
    text-shadow: 0 1px 3px rgba(0,0,0,0.4);
    font-weight: 500;
  }
  .no-calling {
    font-size: 2vh;
    color: rgba(255,255,255,0.6);
    text-align: center;
    font-style: italic;
    padding: 1.5vh 0;
    text-shadow: 0 2px 4px rgba(0,0,0,0.4);
    font-weight: 600;
  }
  .waiting-info {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 1.5vh 2vh;
    background: linear-gradient(135deg, rgba(255, 255, 255, 0.25), rgba(255, 255, 255, 0.15));
    backdrop-filter: blur(20px);
    border-radius: 18px;
    border: 2px solid rgba(255, 255, 255, 0.4);
    box-shadow: 0 8px 25px rgba(0,0,0,0.15);
    flex-shrink: 0;
    position: relative;
    z-index: 1;
  }
  .waiting-count {
    font-size: 1.8vh;
    font-weight: 700;
    color: #ffffff;
    text-shadow: 0 2px 4px rgba(0,0,0,0.5);
    letter-spacing: 0.5px;
  }
  .waiting-number {
    font-size: 2.5vh;
    font-weight: 900;
    color: #ff4757;
    background: rgba(255, 255, 255, 0.95);
    padding: 0.8vh 1.5vh;
    border-radius: 25px;
    box-shadow: 
      0 6px 20px rgba(0,0,0,0.25),
      inset 0 2px 4px rgba(255, 71, 87, 0.2);
    min-width: 3.5vh;
    text-align: center;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    border: 2px solid rgba(255,71,87,0.4);
    text-shadow: 0 1px 2px rgba(0,0,0,0.3);
  }
  .waiting-number.highlight {
    animation: bounceGlow 0.8s ease;
    background: #ff9500;
    color: white;
    transform: scale(1.1);
    box-shadow: 
      0 8px 30px rgba(255, 149, 0, 0.5),
      inset 0 2px 4px rgba(255, 149, 0, 0.3);
  }
  .calling-display {
    transition: all 0.4s ease;
  }
  
  @keyframes bounceGlow {
    0%, 100% { transform: scale(1); }
    25% { transform: scale(1.2); box-shadow: 0 0 30px rgba(255, 149, 0, 0.8); }
    50% { transform: scale(1.1); }
    75% { transform: scale(1.15); }
  }
  
  @keyframes pulse {
    0% { transform: scale(1); opacity: 1; }
    50% { transform: scale(1.08); opacity: 0.9; }
    100% { transform: scale(1); opacity: 1; }
  }
  @keyframes newCall {
    0% { transform: scale(1) translateY(-5px); background-color: transparent; }
    25% { transform: scale(1.03) translateY(-8px); background-color: rgba(0, 255, 136, 0.2); }
    50% { transform: scale(1.02) translateY(-6px); background-color: rgba(0, 255, 136, 0.3); }
    75% { transform: scale(1.01) translateY(-5px); background-color: rgba(0, 255, 136, 0.1); }
    100% { transform: scale(1.02) translateY(-5px); background-color: transparent; }
  }
  .refresh-animation {
    animation: fadeInUp 0.6s ease-out;
  }
  @keyframes fadeInUp {
    0% { opacity: 0; transform: translateY(30px) scale(0.95); }
    100% { opacity: 1; transform: translateY(0) scale(1); }
  }
  @keyframes bounce {
    0%, 20%, 60%, 100% { transform: translateY(0); }
    40% { transform: translateY(-15px); }
    80% { transform: translateY(-8px); }
  }
  @keyframes slideDown {
    from { transform: translateY(-100%); }
    to { transform: translateY(0); }
  }
  @keyframes slideUp {
    from { transform: translateY(0); }
    to { transform: translateY(-100%); }
  }
  
  .error-display {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(255, 0, 0, 0.9);
    color: white;
    padding: 20px;
    border-radius: 10px;
    text-align: center;
    z-index: 10000;
    display: none;
  }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <div class="logo-section">
        <img src="logo.png" alt="Logo Trung t√¢m">
      </div>
      <div class="time" id="currentTime">
        <div class="time-hour" id="timeHour"></div>
        <div class="time-date" id="timeDate"></div>
      </div>
    </div>

    <div class="counters-grid" id="countersGrid">
      <!-- C√°c th·∫ª qu·∫ßy s·∫Ω ƒë∆∞·ª£c t·∫°o t·ª± ƒë·ªông b·∫±ng JavaScript -->
    </div>
  </div>

  <div class="error-display" id="errorDisplay">
    <h3>L·ªói k·∫øt n·ªëi</h3>
    <p>Kh√¥ng th·ªÉ t·∫£i d·ªØ li·ªáu t·ª´ server</p>
  </div>

  <script>
    // Tr√°nh xung ƒë·ªôt v·ªõi c√°c th∆∞ vi·ªán kh√°c
    (function() {
      'use strict';
      
      let lastUpdateTime = null;
      let currentCountersData = {};
      let lastAnnouncementKey = null;
      let isSpeaking = false;
  let speechQueue = [];
  let voicesReady = false;
  let cachedVoices = [];

      // Error handling
      window.addEventListener('error', function(e) {
        console.error('JavaScript Error:', e.error);
        // Kh√¥ng hi·ªÉn th·ªã error popup ƒë·ªÉ tr√°nh l√†m phi·ªÅn ng∆∞·ªùi d√πng
      });

      // H√†m ph√°t √¢m thanh ƒë∆°n gi·∫£n nh∆∞ ti·∫øng g√µ c·ª≠a
      function playKnockSound() {
        try {
          const audioContext = new (window.AudioContext || window.webkitAudioContext)();
          
          const times = [0, 0.15, 0.3];
          
          times.forEach(startTime => {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.setValueAtTime(150, audioContext.currentTime + startTime);
            oscillator.frequency.exponentialRampToValueAtTime(80, audioContext.currentTime + startTime + 0.1);
            
            gainNode.gain.setValueAtTime(0, audioContext.currentTime + startTime);
            gainNode.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + startTime + 0.02);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + startTime + 0.1);
            
            oscillator.start(audioContext.currentTime + startTime);
            oscillator.stop(audioContext.currentTime + startTime + 0.1);
          });
        } catch (error) {
          console.log('Kh√¥ng th·ªÉ ph√°t √¢m thanh:', error);
        }
      }

      // === √ÇM THANH C·∫¢NH B√ÅO TR∆Ø·ªöC KHI PH√ÅT GI·ªåNG N√ìI ===
      let alertAudio = null;
      function initAlertAudio() {
        if (!alertAudio) {
          // ƒê·∫∑t file v√†o public/sound/alert.mp3 (th∆∞ m·ª•c ƒë√£ t·∫°o). N·∫øu kh√¥ng t·ªìn t·∫°i s·∫Ω b·ªè qua.
          alertAudio = new Audio('sound/alert.mp3');
          alertAudio.preload = 'auto';
          alertAudio.volume = 1.0; // ch·ªânh n·∫øu c·∫ßn
        }
        return alertAudio;
      }
      // Tr·∫£ v·ªÅ Promise ho√†n th√†nh khi √¢m thanh c·∫£nh b√°o k·∫øt th√∫c ho·∫∑c l·ªói/timeout
      function playAlertSound() {
        return new Promise(resolve => {
            const audio = initAlertAudio();
            if (!audio) return resolve();
            try {
              audio.currentTime = 0;
              const timeout = setTimeout(() => { resolve(); }, 3000); // tr√°nh treo n·∫øu file h·ªèng
              const done = () => { clearTimeout(timeout); audio.onended = null; audio.onerror = null; resolve(); };
              audio.onended = done;
              audio.onerror = done;
              const playPromise = audio.play();
              if (playPromise && typeof playPromise.then === 'function') {
                playPromise.catch(() => done());
              }
            } catch { resolve(); }
        });
      }

      // H√†m th√¥ng b√°o b·∫±ng gi·ªçng n√≥i ti·∫øng Vi·ªát
      function announceNumber(number, counterNumber, isRecall = false) {
        try {
          const callKey = `${number}-${counterNumber}-${isRecall}`;
          
          // Ki·ªÉm tra n·∫øu ƒëang ph√°t √¢m thanh
          if (isSpeaking || speechSynthesis.speaking) {
            console.log(`‚è≥ ƒêang ph√°t √¢m thanh, th√™m v√†o h√†ng ƒë·ª£i: ${callKey}`);
            // Kh√¥ng th√™m tr√πng l·∫∑p v√†o queue
            if (!speechQueue.find(item => `${item.number}-${item.counterNumber}-${item.isRecall}` === callKey)) {
              speechQueue.push({ number, counterNumber, isRecall });
            }
            return;
          }
          
          console.log(`üé§ announceNumber ƒë∆∞·ª£c g·ªçi: s·ªë ${number}, qu·∫ßy ${counterNumber}${isRecall ? ' (G·ªçi l·∫°i)' : ''}`);
          
          isSpeaking = true;
          speechSynthesis.cancel();
          
          const message = isRecall 
            ? `G·ªçi l·∫°i, xin k√≠nh m·ªùi qu√Ω kh√°ch c√≥ s·ªë th·ª© t·ª± ${number} ƒë·∫øn qu·∫ßy s·ªë ${counterNumber} ƒë·ªÉ th·ª±c hi·ªán th·ªß t·ª•c h√†nh ch√≠nh`
            : `Xin k√≠nh m·ªùi qu√Ω kh√°ch c√≥ s·ªë th·ª© t·ª± ${number} ƒë·∫øn qu·∫ßy s·ªë ${counterNumber} ƒë·ªÉ th·ª±c hi·ªán th·ªß t·ª•c h√†nh ch√≠nh`;
          
          console.log('üì¢ B·∫Øt ƒë·∫ßu ph√°t th√¥ng b√°o:', message);
          
          const utterance = new SpeechSynthesisUtterance(message);
          utterance.lang = 'vi-VN';
          utterance.rate = 0.7;
          utterance.pitch = 1.1;
          utterance.volume = 1.0;
          
          // T√¨m gi·ªçng ti·∫øng Vi·ªát
          const voices = (cachedVoices && cachedVoices.length) ? cachedVoices : speechSynthesis.getVoices();
          let vietnameseVoice = voices.find(voice => 
            voice.lang === 'vi-VN' || 
            voice.lang === 'vi' ||
            voice.name.toLowerCase().includes('mai') ||
            voice.name.toLowerCase().includes('linh') ||
            voice.name.toLowerCase().includes('vietnam')
          );
          
          if (vietnameseVoice) {
            utterance.voice = vietnameseVoice;
            console.log(`‚úÖ S·ª≠ d·ª•ng gi·ªçng Vi·ªát: ${vietnameseVoice.name} (${vietnameseVoice.lang})`);
          } else {
            console.log('‚ö†Ô∏è Kh√¥ng c√≥ gi·ªçng Vi·ªát, s·ª≠ d·ª•ng gi·ªçng m·∫∑c ƒë·ªãnh');
          }
          
          // Event listeners
          utterance.onstart = () => {
            console.log('üîä B·∫ÆT ƒê·∫¶U PH√ÅT √ÇM THANH');
            isSpeaking = true;
            showAnnouncementBanner(message);
          };
          
          utterance.onend = () => {
            console.log('‚úÖ HO√ÄN TH√ÄNH PH√ÅT √ÇM THANH');
            isSpeaking = false;
            
            // X·ª≠ l√Ω h√†ng ƒë·ª£i
            if (speechQueue.length > 0) {
              const next = speechQueue.shift();
              setTimeout(() => {
                announceNumber(next.number, next.counterNumber, next.isRecall);
              }, 1000); // Delay 1 gi√¢y gi·ªØa c√°c th√¥ng b√°o
            }
          };
          
          utterance.onerror = (e) => {
            console.log('‚ùå L·ªñI PH√ÅT √ÇM:', e.error);
            isSpeaking = false;
            playKnockSound();
            
            // X·ª≠ l√Ω h√†ng ƒë·ª£i
            if (speechQueue.length > 0) {
              const next = speechQueue.shift();
              setTimeout(() => {
                announceNumber(next.number, next.counterNumber, next.isRecall);
              }, 1000);
            }
          };
          
          console.log('üîî Ph√°t √¢m thanh c·∫£nh b√°o tr∆∞·ªõc khi ƒë·ªçc...');
          // ƒê·∫∑t isSpeaking = true tr∆∞·ªõc khi ph√°t c·∫£nh b√°o (ƒë√£ ƒë·∫∑t ·ªü tr√™n) ƒë·ªÉ kh√≥a th√™m queue m·ªõi
          playAlertSound().then(async () => {
            console.log('üéØ Chu·∫©n b·ªã ƒë·ªçc sau c·∫£nh b√°o');
            await ensureVoicesReady(1500);
            try { speechSynthesis.resume(); } catch {}
            console.log('üéØ B·∫Øt ƒë·∫ßu ƒë·ªçc');
            speechSynthesis.speak(utterance);
            // Fallback n·∫øu sau 4 gi√¢y k·ªÉ t·ª´ khi b·∫Øt ƒë·∫ßu ƒë·ªçc v·∫´n kh√¥ng n√≥i
            setTimeout(() => {
              if (!speechSynthesis.speaking && isSpeaking) {
                console.log('‚ö†Ô∏è Speech synthesis kh√¥ng ho·∫°t ƒë·ªông (sau c·∫£nh b√°o), fallback knock');
                isSpeaking = false;
                playKnockSound();
              }
            }, 4000);
          });
          
        } catch (error) {
          console.log('‚ùå Kh√¥ng th·ªÉ ph√°t th√¥ng b√°o gi·ªçng n√≥i:', error);
          isSpeaking = false;
          playKnockSound();
        }
      }
      
      // H√†m hi·ªÉn th·ªã banner th√¥ng b√°o tr√™n m√†n h√¨nh
      function showAnnouncementBanner(message) {
        const existingBanner = document.getElementById('announcementBanner');
        if (existingBanner) {
          existingBanner.remove();
        }
        
        const banner = document.createElement('div');
        banner.id = 'announcementBanner';
        banner.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
          color: white;
          text-align: center;
          padding: 20px;
          font-size: 24px;
          font-weight: bold;
          z-index: 9999;
          box-shadow: 0 4px 8px rgba(0,0,0,0.3);
          animation: slideDown 0.5s ease-out;
        `;
        banner.innerHTML = `üîä ${message}`;
        
        document.body.appendChild(banner);
        
        setTimeout(() => {
          if (banner.parentNode) {
            banner.style.animation = 'slideUp 0.5s ease-out';
            setTimeout(() => banner.remove(), 500);
          }
        }, 5000);
      }

      // Mapping lƒ©nh v·ª±c sang s·ªë qu·∫ßy
      const serviceToCounter = {
        "Ch·ª©ng th·ª±c H·ªô t·ªãch": "1",
        "VƒÉn th∆∞": "2", 
        "N·ªôi v·ª• - GDƒêT - VƒÉn h√≥a - Khoa h·ªçc v√† Th√¥ng tin - Y t·∫ø - Lao ƒë·ªông - B·∫£o tr·ª£ X√£ h·ªôi": "3",
  // T√™n th·ªëng nh·∫•t theo server
  "N√¥ng nghi·ªáp v√† M√¥i tr∆∞·ªùng - T√†i ch√≠nh K·∫ø ho·∫°ch - X√¢y d·ª±ng v√† C√¥ng th∆∞∆°ng": "4"
      };

      // Bi·∫øn theo d√µi l·ªánh g·ªçi g·∫ßn nh·∫•t ƒë·ªÉ ph√°t √¢m thanh
      let lastKnownCalls = {};
      
  // Bi·∫øn theo d√µi c√°c s·ªë ƒë√£ ph√°t √¢m thanh ƒë·ªÉ tr√°nh l·∫∑p l·∫°i (service-number-time)
  let announcedNumbers = new Set();

      // H√†m ki·ªÉm tra v√† ph√°t √¢m thanh cho l·ªánh g·ªçi m·ªõi
      function checkForNewCalls() {
  const apiBaseUrl = getApiBaseUrl();
  fetch(`${apiBaseUrl}/latest-calls`)
          .then(res => {
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            return res.json();
          })
          .then(latestCalls => {
            console.log('üì° Ki·ªÉm tra l·ªánh g·ªçi m·ªõi:', latestCalls);
            
            for (const service in latestCalls) {
              const latestCall = latestCalls[service];
              if (latestCall && latestCall.number) {
                const callId = `${service}-${latestCall.number}-${latestCall.time}`;
                
                // Ki·ªÉm tra xem s·ªë n√†y ƒë√£ ƒë∆∞·ª£c ph√°t ch∆∞a
                if (!announcedNumbers.has(callId)) {
                  console.log(`üÜï Ph√°t hi·ªán l·ªánh g·ªçi m·ªõi cho ${service}!`);
                  
                  // ∆Øu ti√™n d√πng counterNumber server tr·∫£ v·ªÅ ƒë·ªÉ tr√°nh l·ªách map t√™n d·ªãch v·ª•
                  const counterNumber = (latestCall.counter != null && latestCall.counter !== '')
                    ? String(latestCall.counter)
                    : serviceToCounter[service];
                  if (counterNumber) {
                    console.log(`üîî Ph√°t th√¥ng b√°o cho l·ªánh g·ªçi m·ªõi: ${latestCall.number} - Qu·∫ßy ${counterNumber}${latestCall.isRecall ? ' (G·ªçi l·∫°i)' : ''}`);
                    announceNumber(latestCall.number, counterNumber, latestCall.isRecall || false);
                    
                    // ƒê√°nh d·∫•u s·ªë n√†y ƒë√£ ƒë∆∞·ª£c ph√°t
                    announcedNumbers.add(callId);
                    console.log(`‚úÖ ƒê√£ ƒë√°nh d·∫•u s·ªë ${latestCall.number} ƒë√£ ph√°t, t·ªïng ƒë√£ ph√°t: ${announcedNumbers.size}`);
                    
                    // X√≥a c√°c callId c≈© ƒë·ªÉ tr√°nh memory leak (gi·ªØ l·∫°i 100 s·ªë g·∫ßn nh·∫•t)
                    if (announcedNumbers.size > 100) {
                      const oldestEntries = Array.from(announcedNumbers).slice(0, 50);
                      oldestEntries.forEach(id => announcedNumbers.delete(id));
                      console.log(`üßπ ƒê√£ d·ªçn d·∫πp 50 callId c≈©, c√≤n l·∫°i: ${announcedNumbers.size}`);
                    }
                  } else {
                    console.log(`‚ùå Kh√¥ng t√¨m th·∫•y counter number cho service: ${service} (server c≈©ng kh√¥ng cung c·∫•p). B·ªè qua ph√°t √¢m thanh.`);
                  }
                  
                  lastKnownCalls[service] = {
                    number: latestCall.number,
                    time: latestCall.time
                  };
                } else {
                  console.log(`üîá B·ªè qua s·ªë ${latestCall.number} cho ${service} - ƒë√£ ph√°t r·ªìi`);
                }
              }
            }
          })
          .catch(error => {
            console.error('‚ùå L·ªói khi ki·ªÉm tra l·ªánh g·ªçi m·ªõi:', error);
          });
      }

      // Function ƒë·ªÉ reset danh s√°ch s·ªë ƒë√£ ph√°t (cho admin)
      function resetAnnouncedNumbers() {
        announcedNumbers.clear();
        lastKnownCalls = {};
        speechQueue.length = 0;
        console.log('üîÑ ƒê√£ reset t·∫•t c·∫£ s·ªë ƒë√£ ph√°t. M·ªçi l·ªánh g·ªçi s·∫Ω ƒë∆∞·ª£c ph√°t l·∫°i.');
        alert('ƒê√£ reset danh s√°ch s·ªë ƒë√£ ph√°t. M·ªçi l·ªánh g·ªçi s·∫Ω ƒë∆∞·ª£c ph√°t l·∫°i t·ª´ ƒë·∫ßu.');
      }

      // Th√™m ph√≠m t·∫Øt Ctrl+R ƒë·ªÉ reset announced numbers
      document.addEventListener('keydown', function(e) {
        if (e.ctrlKey && e.key === 'r') {
          e.preventDefault();
          if (confirm('Reset danh s√°ch s·ªë ƒë√£ ph√°t? M·ªçi l·ªánh g·ªçi s·∫Ω ƒë∆∞·ª£c ph√°t l·∫°i.')) {
            resetAnnouncedNumbers();
          }
        }
      });

      function updateCurrentTime() {
        try {
          const now = new Date();
          
          const timeHour = now.toLocaleTimeString('vi-VN', {
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit'
          });
          const hourElement = document.getElementById('timeHour');
          if (hourElement) hourElement.textContent = timeHour;
          
          const timeDate = now.toLocaleDateString('vi-VN', {
            weekday: 'long',
            day: '2-digit',
            month: '2-digit',
            year: 'numeric'
          });
          const dateElement = document.getElementById('timeDate');
          if (dateElement) dateElement.textContent = timeDate;
        } catch (error) {
          console.error('L·ªói c·∫≠p nh·∫≠t th·ªùi gian:', error);
        }
      }

      function formatTime(timeString) {
        try {
          const date = new Date(timeString);
          return date.toLocaleTimeString('vi-VN', {
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit'
          });
        } catch (error) {
          return 'N/A';
        }
      }

      function formatDate(timeString) {
        try {
          const date = new Date(timeString);
          return date.toLocaleDateString('vi-VN', {
            day: '2-digit',
            month: '2-digit',
            hour: '2-digit',
            minute: '2-digit'
          });
        } catch (error) {
          return 'N/A';
        }
      }

      function createCounterCard(counter) {
        try {
          const hasCurrentCall = counter.currentCalling !== null;
          const cardClass = hasCurrentCall ? 'counter-card active' : 'counter-card';
          
          return `
            <div class="${cardClass}" data-service="${counter.service}">
              <div class="counter-header">
                <div class="counter-number">QU·∫¶Y ${counter.counterNumber}</div>
                <div class="service-name">${counter.service}</div>
              </div>
              
              <div class="current-calling">
                <div class="calling-label">ƒêang g·ªçi</div>
                <div class="calling-display">
                  ${hasCurrentCall ? `
                    <div class="calling-number">${counter.currentCalling.number}</div>
                    <div class="calling-time">G·ªçi l√∫c: ${formatDate(counter.currentCalling.time)}</div>
                  ` : `
                    <div class="no-calling">Ch∆∞a c√≥</div>
                  `}
                </div>
              </div>
              
              <div class="waiting-info">
                <span class="waiting-count">Kh√°ch ƒëang ch·ªù:</span>
                <span class="waiting-number">${counter.waitingCount}</span>
              </div>
            </div>
          `;
        } catch (error) {
          console.error('L·ªói t·∫°o counter card:', error);
          return '<div class="counter-card">L·ªói hi·ªÉn th·ªã</div>';
        }
      }

      function updateCounterCard(card, counter) {
        try {
          const hasCurrentCall = counter.currentCalling !== null;
          const oldData = currentCountersData[counter.service];
          
          const isNewCall = hasCurrentCall && (!oldData || 
            !oldData.currentCalling || 
            oldData.currentCalling.number !== counter.currentCalling.number);
          
          if (hasCurrentCall && !card.classList.contains('active')) {
            card.classList.add('active');
          } else if (!hasCurrentCall && card.classList.contains('active')) {
            card.classList.remove('active');
          }
          
          const callingDisplay = card.querySelector('.calling-display');
          if (callingDisplay) {
            const newCallingContent = hasCurrentCall ? `
              <div class="calling-number">${counter.currentCalling.number}</div>
              <div class="calling-time">G·ªçi l√∫c: ${formatDate(counter.currentCalling.time)}</div>
            ` : `
              <div class="no-calling">Ch∆∞a c√≥</div>
            `;
            
            if (callingDisplay.innerHTML.trim() !== newCallingContent.trim()) {
              callingDisplay.style.opacity = '0.5';
              setTimeout(() => {
                callingDisplay.innerHTML = newCallingContent;
                callingDisplay.style.opacity = '1';
              }, 150);
            }
          }

          // C·∫≠p nh·∫≠t t√™n lƒ©nh v·ª±c n·∫øu c·∫ßn
          const serviceNameEl = card.querySelector('.service-name');
          if (serviceNameEl && serviceNameEl.textContent !== counter.service) {
            serviceNameEl.textContent = counter.service;
          }
          
          const waitingNumber = card.querySelector('.waiting-number');
          if (waitingNumber && waitingNumber.textContent !== counter.waitingCount.toString()) {
            waitingNumber.style.transform = 'scale(1.2)';
            waitingNumber.textContent = counter.waitingCount;
            
            waitingNumber.classList.add('highlight');
            setTimeout(() => {
              waitingNumber.style.transform = 'scale(1)';
              waitingNumber.classList.remove('highlight');
            }, 600);
          }
          
          if (isNewCall) {
            console.log('üÜï S·ªë m·ªõi ƒë∆∞·ª£c g·ªçi:', counter.currentCalling.number, 't·∫°i qu·∫ßy', counter.counterNumber);
            
            card.style.animation = 'newCall 2s ease-in-out';
            setTimeout(() => {
              card.style.animation = '';
            }, 2000);
            
            const callingNumberElement = card.querySelector('.calling-number');
            if (callingNumberElement) {
              callingNumberElement.style.animation = 'pulse 1s ease-in-out 3';
              setTimeout(() => {
                callingNumberElement.style.animation = '';
              }, 3000);
            }

            // Fallback ph√°t √¢m thanh n·∫øu API /latest-calls kh√¥ng ho·∫°t ƒë·ªông
            try {
              const callId = `${counter.service}-${counter.currentCalling.number}-${counter.currentCalling.time}`;
              if (!announcedNumbers.has(callId)) {
                console.log('üîà Fallback announce (from status change):', callId);
                announceNumber(counter.currentCalling.number, counter.counterNumber, false);
                announcedNumbers.add(callId);
                // D·ªçn c≈© n·∫øu v∆∞·ª£t qu√° 100
                if (announcedNumbers.size > 120) {
                  const oldest = Array.from(announcedNumbers).slice(0, 20);
                  oldest.forEach(id => announcedNumbers.delete(id));
                }
              }
            } catch (e) {
              console.log('‚ö†Ô∏è Fallback announce error:', e);
            }
          }
        } catch (error) {
          console.error('L·ªói c·∫≠p nh·∫≠t counter card:', error);
        }
      }

      async function loadCountersStatus() {
        try {
          const apiBaseUrl = getApiBaseUrl();
          const response = await fetch(`${apiBaseUrl}/all-counters-status`);
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          
          const data = await response.json();
          console.log('üìä D·ªØ li·ªáu qu·∫ßy nh·∫≠n ƒë∆∞·ª£c:', data);
          
          const grid = document.getElementById('countersGrid');
          if (!grid) return;
          
          // Ki·ªÉm tra n·∫øu grid tr·ªëng th√¨ t·∫°o c√°c card ban ƒë·∫ßu
          if (grid.children.length === 0) {
            data.counters.forEach(counter => {
              const cardHTML = createCounterCard(counter);
              grid.insertAdjacentHTML('beforeend', cardHTML);
            });
          } else {
            // C·∫≠p nh·∫≠t c√°c card hi·ªán c√≥
            data.counters.forEach(counter => {
              const card = grid.querySelector(`[data-service="${counter.service}"]`);
              if (card) {
                updateCounterCard(card, counter);
              }
            });
          }
          
          currentCountersData = {};
          data.counters.forEach(counter => {
            currentCountersData[counter.service] = counter;
          });
          
          lastUpdateTime = Date.now();
          
          // ·∫®n error display n·∫øu c√≥
          const errorDisplay = document.getElementById('errorDisplay');
          if (errorDisplay) errorDisplay.style.display = 'none';
          
        } catch (error) {
          console.error('‚ùå L·ªói khi t·∫£i d·ªØ li·ªáu qu·∫ßy:', error);
          
          // Hi·ªÉn th·ªã error display
          const errorDisplay = document.getElementById('errorDisplay');
          if (errorDisplay) {
            errorDisplay.style.display = 'block';
            setTimeout(() => {
              errorDisplay.style.display = 'none';
            }, 3000);
          }
          
          setTimeout(() => {
            loadCountersStatus();
          }, 3000);
        }
      }

      // Kh·ªüi t·∫°o
      function init() {
        try {
          console.log('üöÄ Kh·ªüi t·∫°o m√†n h√¨nh hi·ªÉn th·ªã t·∫•t c·∫£ qu·∫ßy');
          console.log('üåê API Base URL:', getApiBaseUrl());
          // Chu·∫©n b·ªã gi·ªçng n√≥i TTS s·ªõm
          primeVoices();
          
          updateCurrentTime();
          loadCountersStatus();
          
          setInterval(updateCurrentTime, 1000);
          // Gi·∫£m chu k·ª≥ ƒë·ªÉ ph√°t √¢m thanh nhanh h∆°n
          setInterval(loadCountersStatus, 2000); // 2s c·∫≠p nh·∫≠t tr·∫°ng th√°i qu·∫ßy
          setInterval(checkForNewCalls, 1500);   // 1.5s ki·ªÉm tra s·ªë m·ªõi g·ªçi
          setTimeout(checkForNewCalls, 300);     // ch·∫°y s·ªõm sau khi load
          
          console.log('‚úÖ Kh·ªüi t·∫°o ho√†n t·∫•t');
        } catch (error) {
          console.error('‚ùå L·ªói kh·ªüi t·∫°o:', error);
        }
      }

      // Kh·ªüi t·∫°o khi DOM load xong
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
      } else {
        init();
      }

      let isPageVisible = true;
      let refreshInterval;

      document.addEventListener('visibilitychange', () => {
        try {
          if (document.hidden) {
            isPageVisible = false;
            console.log('üì± Trang web b·ªã ·∫©n - Gi·∫£m t·∫ßn su·∫•t c·∫≠p nh·∫≠t');
            clearInterval(refreshInterval);
            refreshInterval = setInterval(loadCountersStatus, 5000); // gi·∫£m c√≤n 5s
          } else {
            isPageVisible = true;
            console.log('üì± Trang web ƒë∆∞·ª£c hi·ªÉn th·ªã - Kh√¥i ph·ª•c t·∫ßn su·∫•t c·∫≠p nh·∫≠t');
            clearInterval(refreshInterval);
            refreshInterval = setInterval(loadCountersStatus, 2000); // gi·∫£m c√≤n 2s
            
            setTimeout(loadCountersStatus, 500);
          }
        } catch (error) {
          console.error('L·ªói visibility change:', error);
        }
      });
      
      // Helper: ƒë·ªçc query param v√† ch·ªçn API base URL
      function getApiBaseUrl() {
        try {
          const params = new URLSearchParams(window.location.search || '');
          const override = params.get('api');
          if (override && /^https?:\/\//i.test(override)) {
            return override.replace(/\/$/, '');
          }
          // N·∫øu ch·∫°y t·ª´ file://, fallback localhost:3000
          if (location.protocol === 'file:') {
            return 'http://localhost:3000';
          }
          return window.location.origin;
        } catch {
          return window.location.origin;
        }
      }

      // Chu·∫©n b·ªã & ƒë·ª£i voices cho SpeechSynthesis
      function primeVoices() {
        try {
          const v = speechSynthesis.getVoices();
          if (v && v.length) {
            cachedVoices = v;
            voicesReady = true;
          }
          speechSynthesis.onvoiceschanged = () => {
            const voices = speechSynthesis.getVoices();
            if (voices && voices.length) {
              cachedVoices = voices;
              voicesReady = true;
              console.log(`üéôÔ∏è Voices loaded: ${voices.length}`);
            }
          };
        } catch (e) {
          console.log('‚ö†Ô∏è Kh√¥ng th·ªÉ prime voices:', e);
        }
      }

      function ensureVoicesReady(timeoutMs = 1500) {
        return new Promise(resolve => {
          try {
            if (voicesReady && cachedVoices && cachedVoices.length) return resolve();
            const start = Date.now();
            const check = () => {
              if (voicesReady && cachedVoices && cachedVoices.length) return resolve();
              if (Date.now() - start >= timeoutMs) return resolve();
              setTimeout(check, 100);
            };
            check();
          } catch { resolve(); }
        });
      }

    })(); // End IIFE
  </script>
</body>
</html>
